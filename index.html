<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FaceSwap Studio - Professional</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        #result-canvas {
            touch-action: none;
            max-width: 100%;
            display: block;
            background: #f0f0f0;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        .upload-zone {
            transition: border-color 0.2s ease;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .upload-zone.drag-over {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        .preview-container {
            position: relative;
        }
        .replace-button {
            position: absolute;
            bottom: 8px;
            right: 8px;
            z-index: 10;
        }
        .swap-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .upload-zone:hover .swap-button {
            opacity: 1;
        }
        .face-thumbnail {
            width: 60px;
            height: 60px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            overflow: hidden;
        }
        .face-thumbnail.active {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #3b82f6;
        }
        .face-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .tool-button {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
        }
        .tool-button.active {
            background-color: #3b82f6;
            color: white;
        }
        .preview-mode-button {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
        }
        .preview-mode-button.active {
            background-color: #e5e7eb;
        }
        @media (max-width: 768px) {
            .controls-wrapper {
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease-out;
            }
            .controls-wrapper.active {
                max-height: 1000px;
            }
        }
        .toast {
            animation: slideIn 0.3s, fadeOut 0.3s 2.7s forwards;
        }
        @keyframes slideIn {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .landmark-point {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #ff0000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }
        .comparison-slider {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: white;
            cursor: col-resize;
            z-index: 5;
        }
        .comparison-slider::after {
            content: '';
            position: absolute;
            top: 50%;
            left: -10px;
            transform: translateY(-50%);
            width: 20px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            z-index: -1;
        }
        .download-button {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .download-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 7px 14px -3px rgba(0, 0, 0, 0.2), 0 3px 6px -2px rgba(0, 0, 0, 0.12);
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <header class="bg-white shadow-sm sticky top-0 z-50">
        <div class="max-w-7xl mx-auto p-4 flex flex-col sm:flex-row justify-between items-center">
            <div>
                <h1 class="text-2xl font-bold text-gray-900">FaceSwap Studio Pro</h1>
                <p class="text-sm text-gray-500 flex items-center gap-1">
                    <span class="inline-block w-2 h-2 bg-green-500 rounded-full"></span>
                    On-device • Private • Realistic
                </p>
            </div>
            <div class="flex space-x-2">
                <button id="help-button" class="p-2 hover:bg-gray-100 rounded-full">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto p-4 grid grid-cols-1 lg:grid-cols-[1fr_2fr_1fr] gap-4">
        <!-- Source Upload Zone -->
        <section class="bg-white rounded-2xl p-4 shadow-sm relative">
            <div class="absolute -top-3 left-1/2 transform -translate-x-1/2 z-10">
                <button id="swap-direction" class="swap-button bg-white p-2 rounded-full shadow-md hover:bg-gray-100 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
                    </svg>
                </button>
            </div>
            <h2 class="text-lg font-semibold mb-2">Source (Face to Swap)</h2>
            <div id="source-upload" class="upload-zone border-2 border-dashed border-gray-300 rounded-xl p-4 text-center cursor-pointer hover:border-gray-400">
                <input type="file" id="source-input" accept="image/*" class="hidden">
                <div class="text-gray-500">
                    <p>Drag & drop source image here</p>
                    <p class="text-sm">or click to upload</p>
                </div>
                <div id="source-preview" class="mt-2 hidden preview-container">
                    <img class="max-w-full h-auto mx-auto rounded-lg" src="" alt="Source preview">
                    <p class="text-sm text-gray-500 mt-1" id="source-file-info"></p>
                    <button class="mt-2 px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600 replace-button" data-target="source">Replace</button>
                </div>
            </div>
            <div class="mt-4">
                <h3 class="text-md font-medium mb-2">Source Face</h3>
                <div id="source-face-selection" class="flex flex-wrap gap-2">
                    <!-- Face thumbnails will be added here -->
                </div>
            </div>
        </section>

        <!-- Canvas Workspace -->
        <section class="bg-white rounded-2xl p-4 shadow-sm flex flex-col">
            <div class="toolbar flex justify-between items-center mb-2">
                <div class="flex space-x-2">
                    <button class="p-2 rounded hover:bg-gray-100" id="undo" title="Undo (Ctrl+Z)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4 2a1 1 0 00-1 1v14a1 1 0 001 1h10a1 1 0 001-1V3a1 1 0 00-1-1H4zm3 1h6v12H7V3z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <button class="p-2 rounded hover:bg-gray-100" id="redo" title="Redo (Ctrl+Y)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4 2a1 1 0 00-1 1v14a1 1 0 001 1h10a1 1 0 001-1V3a1 1 0 00-1-1H4zm3 1h6v12H7V3z" clip-rule="evenodd" />
                        </svg>
                    </button>
                    <button class="p-2 rounded hover:bg-gray-100" id="reset" title="Reset All Settings">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1.323l3.954 5.576L14.485 7H15a1 1 0 110 2h-2.97l-1.99 2.5a1 1 0 01-1.33.345l-1.204-.995-2.047 2.08a1 1 0 01-.63.426H8.5a1 1 0 01-.63-.426L5.443 9.688a1 1 0 01-.33-.113H4a1 1 0 110-2h1.485L3.046 5.424l1.492-1.76a1 1 0 011.33-.345L7.03 4H9a1 1 0 110 2h1.323l-2.382 2.844a1 1 0 01-.86.992z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
                <div class="flex space-x-2">
                    <div class="flex space-x-1 bg-gray-100 p-1 rounded-lg">
                        <button class="preview-mode-button active" id="preview-single" title="Single View">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 5a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM4 13a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1v-6zM16 13a1 1 0 011-1h2a1 1 0 011 1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1v-6z" />
                            </svg>
                        </button>
                        <button class="preview-mode-button" id="preview-split" title="Split View">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 5a1 1 0 011-1h14a1 1 0 011 1v2a1 1 0 01-1 1H5a1 1 0 01-1-1V5zM4 13a1 1 0 011-1h14a1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1v-6z" />
                            </svg>
                        </button>
                        <button class="preview-mode-button" id="preview-compare" title="Before/After Slider">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-4 0V5a2 2 0 114 0v2m-4 0h4m-4 0h-4m-1 6h8m0 0v4m0-4H9m4 0v4m-4-4v-1m0 1v1m7-4h-4" />
                            </svg>
                        </button>
                    </div>
                    <button class="p-2 rounded hover:bg-gray-100" id="grid-toggle" title="Toggle Grid">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 3a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V3zM11 11a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
                        </svg>
                    </button>
                    <button class="p-2 rounded hover:bg-gray-100" id="landmarks-toggle" title="Toggle Face Landmarks">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
            </div>
            <div class="relative flex-1 overflow-hidden">
                <div id="comparison-container" class="w-full h-full relative">
                    <canvas id="result-canvas" class="w-full h-full"></canvas>
                    <div id="comparison-slider" class="comparison-slider hidden"></div>
                </div>
                <div id="zoom-pan-info" class="absolute bottom-2 right-2 bg-gray-800 text-white text-xs px-2 py-1 rounded"></div>
            </div>
        </section>

        <!-- Right Column: Target Upload + Controls -->
        <div class="flex flex-col gap-4">
            <!-- Target Upload Zone -->
            <section class="bg-white rounded-2xl p-4 shadow-sm relative">
                <h2 class="text-lg font-semibold mb-2">Target (Background/Face)</h2>
                <div id="target-upload" class="upload-zone border-2 border-dashed border-gray-300 rounded-xl p-4 text-center cursor-pointer hover:border-gray-400">
                    <input type="file" id="target-input" accept="image/*" class="hidden">
                    <div class="text-gray-500">
                        <p>Drag & drop target image here</p>
                        <p class="text-sm">or click to upload</p>
                    </div>
                    <div id="target-preview" class="mt-2 hidden preview-container">
                        <img class="max-w-full h-auto mx-auto rounded-lg" src="" alt="Target preview">
                        <p class="text-sm text-gray-500 mt-1" id="target-file-info"></p>
                        <button class="mt-2 px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600 replace-button" data-target="target">Replace</button>
                    </div>
                </div>
                <div class="mt-4">
                    <h3 class="text-md font-medium mb-2">Target Faces</h3>
                    <div id="target-face-selection" class="flex flex-wrap gap-2">
                        <!-- Face thumbnails will be added here -->
                    </div>
                </div>
            </section>

            <!-- Controls Panel -->
            <section class="bg-white rounded-2xl p-4 shadow-sm controls-wrapper">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-semibold">Controls</h2>
                    <button id="toggle-controls" class="md:hidden p-2 rounded hover:bg-gray-100">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
                
                <!-- Face Detection Controls -->
                <div class="mb-4">
                    <h3 class="text-md font-medium mb-2">Face Detection</h3>
                    <div class="space-y-2">
                        <button id="re-run" class="w-full px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">Re-run Detection</button>
                        <div id="face-pick" class="hidden">
                            <p class="text-sm text-gray-500 mb-1">Select face:</p>
                            <div id="face-thumbs" class="flex flex-wrap gap-2"></div>
                        </div>
                        <button id="auto-align" class="w-full px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600">Auto Align Faces</button>
                    </div>
                </div>

                <!-- Face Selection -->
                <div class="mb-4">
                    <h3 class="text-md font-medium mb-2">Face Selection</h3>
                    <div class="space-y-2">
                        <div class="flex justify-between items-center">
                            <label class="text-sm text-gray-600">Source Face</label>
                            <div id="source-face-indicator" class="w-6 h-6 rounded-full bg-gray-200 flex items-center justify-center">1</div>
                        </div>
                        <div class="flex justify-between items-center">
                            <label class="text-sm text-gray-600">Target Face</label>
                            <div id="target-face-indicator" class="w-6 h-6 rounded-full bg-gray-200 flex items-center justify-center">1</div>
                        </div>
                        <div class="flex space-x-2">
                            <button id="match-faces" class="flex-1 px-3 py-2 bg-purple-500 text-white rounded hover:bg-purple-600">Match Faces</button>
                            <button id="swap-faces" class="flex-1 px-3 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600">Swap Faces</button>
                        </div>
                    </div>
                </div>

                <!-- Geometry & Blend Controls -->
                <div class="mb-4">
                    <h3 class="text-md font-medium mb-2">Geometry & Blend</h3>
                    <div class="space-y-2">
                        <div>
                            <label class="text-sm text-gray-600">Scale</label>
                            <input type="range" id="scale" min="0.5" max="1.5" step="0.01" value="1" class="w-full">
                            <span id="scale-value" class="text-xs text-gray-500">1.00</span>
                        </div>
                        <div>
                            <label class="text-sm text-gray-600">Rotation</label>
                            <input type="range" id="rotation" min="-20" max="20" step="0.1" value="0" class="w-full">
                            <span id="rotation-value" class="text-xs text-gray-500">0.0°</span>
                        </div>
                        <div>
                            <label class="text-sm text-gray-600">X Offset</label>
                            <input type="range" id="x-offset" min="-50" max="50" step="1" value="0" class="w-full">
                            <span id="x-offset-value" class="text-xs text-gray-500">0px</span>
                        </div>
                        <div>
                            <label class="text-sm text-gray-600">Y Offset</label>
                            <input type="range" id="y-offset" min="-50" max="50" step="1" value="0" class="w-full">
                            <span id="y-offset-value" class="text-xs text-gray-500">0px</span>
                        </div>
                        <div>
                            <label class="text-sm text-gray-600">Feather Radius</label>
                            <input type="range" id="feather" min="0" max="20" step="1" value="5" class="w-full">
                            <span id="feather-value" class="text-xs text-gray-500">5px</span>
                        </div>
                        <div>
                            <label class="text-sm text-gray-600">Color Match</label>
                            <div class="flex space-x-2 mt-1">
                                <button id="color-match-off" class="tool-button flex-1 bg-gray-100">Off</button>
                                <button id="color-match-simple" class="tool-button flex-1 bg-gray-100">Simple</button>
                                <button id="color-match-advanced" class="tool-button flex-1 bg-gray-100 active">Advanced</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Mask Editing -->
                <div class="mb-4">
                    <h3 class="text-md font-medium mb-2">Mask Editing</h3>
                    <div class="space-y-2">
                        <div class="flex space-x-2">
                            <button id="mask-tool" class="tool-button bg-gray-100 active">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                                </svg>
                            </button>
                            <button id="brush-size" class="flex-1 px-3 py-1 bg-gray-100 rounded text-sm">Size: 20px</button>
                        </div>
                        <div class="flex space-x-2">
                            <button id="mask-mode-paint" class="tool-button flex-1 bg-gray-100 active">Paint</button>
                            <button id="mask-mode-erase" class="tool-button flex-1 bg-gray-100">Erase</button>
                        </div>
                    </div>
                </div>
                
                <!-- Export Controls -->
                <div class="mt-6 pt-4 border-t border-gray-200">
                    <div class="flex flex-col space-y-3">
                        <div class="flex items-center">
                            <input type="checkbox" id="watermark-checkbox" class="mr-2 h-4 w-4 text-indigo-600 rounded focus:ring-indigo-500" checked>
                            <label for="watermark-checkbox" class="text-sm text-gray-600">Add watermark</label>
                        </div>
                        <button id="download-button" class="download-button w-full px-4 py-2.5 text-white font-medium rounded-lg">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                            </svg>
                            Download Result
                        </button>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <!-- Footer -->
    <footer class="max-w-7xl mx-auto p-4">
        <div class="bg-white rounded-2xl p-4 shadow-sm">
            <div class="flex items-start space-x-2">
                <input type="checkbox" id="consent-checkbox" class="mt-1" checked>
                <label for="consent-checkbox" class="text-sm text-gray-600">
                    I have consent from all people in these images. I will not use the output to deceive, harass, or violate rights.
                </label>
            </div>
            <p class="text-xs text-gray-500 mt-2">
                Faceswap Studio Pro is for ethical, non-commercial use only. By exporting, you agree to use responsibly.
            </p>
        </div>
    </footer>

    <!-- Help Modal -->
    <div id="help-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 transition-opacity z-50">
        <div class="relative mx-auto mt-20 max-w-xl">
            <div class="bg-white rounded-2xl p-6 shadow-lg">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-bold">Keyboard Shortcuts</h3>
                    <button id="close-help" class="p-2 hover:bg-gray-100 rounded-full">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
                <div class="grid grid-cols-2 gap-4 text-sm">
                    <div class="font-medium">General</div>
                    <div></div>
                    <div>Ctrl/Cmd + O</div>
                    <div>Open target image</div>
                    <div>Ctrl/Cmd + Shift + O</div>
                    <div>Open source image</div>
                    <div>Ctrl/Cmd + S</div>
                    <div>Download result</div>
                    
                    <div class="font-medium mt-2">Navigation</div>
                    <div></div>
                    <div>Space + Drag</div>
                    <div>Pan view</div>
                    <div>Mouse Wheel</div>
                    <div>Zoom in/out</div>
                    <div>+/-</div>
                    <div>Zoom in/out</div>
                    <div>0</div>
                    <div>Fit to screen</div>
                    
                    <div class="font-medium mt-2">Editing</div>
                    <div></div>
                    <div>Z/Y</div>
                    <div>Undo/Redo</div>
                    <div>[ / ]</div>
                    <div>Adjust brush size</div>
                    <div>B</div>
                    <div>Toggle mask brush</div>
                    <div>E</div>
                    <div>Toggle erase mode</div>
                    <div>H</div>
                    <div>Toggle mask view</div>
                    <div>G</div>
                    <div>Toggle grid</div>
                    <div>L</div>
                    <div>Toggle landmarks</div>
                    <div>C</div>
                    <div>Compare (hold)</div>
                </div>
                <div class="mt-4 p-3 bg-blue-50 rounded-lg">
                    <p class="text-sm text-blue-800">
                        <strong>Pro Tip:</strong> For best results, select matching face angles and expressions. The advanced color matching works best when faces have similar lighting.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toast-container" class="fixed bottom-4 right-4 space-y-2"></div>

    <script>
        // IIFE to avoid global scope pollution
        (function() {
            // State Management
            const state = {
                sourceImage: null,
                targetImage: null,
                sourceCanvas: null,
                targetCanvas: null,
                resultCanvas: document.getElementById('result-canvas'),
                resultCtx: document.getElementById('result-canvas').getContext('2d'),
                maskCanvas: null,
                maskCtx: null,
                comparisonSlider: document.getElementById('comparison-slider'),
                currentFaceIndex: 0,
                selectedSourceFace: 0,
                selectedTargetFace: 0,
                faces: { source: [], target: [] },
                settings: {
                    scale: 1,
                    rotation: 0,
                    xOffset: 0,
                    yOffset: 0,
                    feather: 5,
                    edgeSmooth: 3,
                    colorMatch: 'advanced',
                    skinTone: 0,
                    brightness: 0,
                    contrast: 0,
                    saturation: 0,
                    brushSize: 20,
                    brushHard: false,
                    maskErase: false,
                    colorTransfer: 'advanced',
                    outputFormat: 'image/png',
                    outputQuality: 90,
                    addWatermark: true,
                    watermarkText: 'FaceSwap Studio Pro',
                    watermarkOpacity: 50,
                    watermarkSize: 20,
                    watermarkPosition: 'bottom-right',
                    stripMeta: true,
                    previewMode: 'single', // single, split, compare
                    showLandmarks: false,
                    showGrid: false
                },
                undoStack: [],
                redoStack: [],
                isComparing: false,
                isDragging: false,
                dragStart: { x: 0, y: 0 },
                panOffset: { x: 0, y: 0 },
                zoomLevel: 1,
                hasChanges: false,
                comparisonPosition: 0.5, // 0-1
                maskEditing: false,
                maskBrushSize: 20,
                maskMode: 'paint' // paint, erase
            };

            // DOM References
            const dom = {
                sourceUpload: document.getElementById('source-upload'),
                sourceInput: document.getElementById('source-input'),
                sourcePreview: document.getElementById('source-preview'),
                sourceFileInfo: document.getElementById('source-file-info'),
                sourceFaceSelection: document.getElementById('source-face-selection'),
                targetUpload: document.getElementById('target-upload'),
                targetInput: document.getElementById('target-input'),
                targetPreview: document.getElementById('target-preview'),
                targetFileInfo: document.getElementById('target-file-info'),
                targetFaceSelection: document.getElementById('target-face-selection'),
                resultCanvas: document.getElementById('result-canvas'),
                resultCtx: document.getElementById('result-canvas').getContext('2d'),
                zoomPanInfo: document.getElementById('zoom-pan-info'),
                comparisonSlider: document.getElementById('comparison-slider'),
                toggleControls: document.getElementById('toggle-controls'),
                controlsWrapper: document.querySelector('.controls-wrapper'),
                scaleSlider: document.getElementById('scale'),
                scaleValue: document.getElementById('scale-value'),
                rotationSlider: document.getElementById('rotation'),
                rotationValue: document.getElementById('rotation-value'),
                xOffsetSlider: document.getElementById('x-offset'),
                xOffsetValue: document.getElementById('x-offset-value'),
                yOffsetSlider: document.getElementById('y-offset'),
                yOffsetValue: document.getElementById('y-offset-value'),
                featherSlider: document.getElementById('feather'),
                featherValue: document.getElementById('feather-value'),
                reRunButton: document.getElementById('re-run'),
                autoAlignButton: document.getElementById('auto-align'),
                matchFacesButton: document.getElementById('match-faces'),
                swapFacesButton: document.getElementById('swap-faces'),
                sourceFaceIndicator: document.getElementById('source-face-indicator'),
                targetFaceIndicator: document.getElementById('target-face-indicator'),
                colorMatchOff: document.getElementById('color-match-off'),
                colorMatchSimple: document.getElementById('color-match-simple'),
                colorMatchAdvanced: document.getElementById('color-match-advanced'),
                maskTool: document.getElementById('mask-tool'),
                brushSize: document.getElementById('brush-size'),
                maskModePaint: document.getElementById('mask-mode-paint'),
                maskModeErase: document.getElementById('mask-mode-erase'),
                previewSingle: document.getElementById('preview-single'),
                previewSplit: document.getElementById('preview-split'),
                previewCompare: document.getElementById('preview-compare'),
                gridToggle: document.getElementById('grid-toggle'),
                landmarksToggle: document.getElementById('landmarks-toggle'),
                watermarkCheckbox: document.getElementById('watermark-checkbox'),
                downloadButton: document.getElementById('download-button'),
                swapDirection: document.getElementById('swap-direction')
            };

            // Initialize application
            async function initApp() {
                try {
                    // Set up canvas dimensions based on container
                    setupCanvasDimensions();
                    
                    // Load face-api models
                    await loadFaceApiModels();
                    
                    // Setup event listeners
                    setupEventListeners();

                    // Initial render
                    renderCanvas();
                    
                    // Show welcome toast
                    showToast('FaceSwap Studio Pro ready! Upload images to begin.', 'success');
                } catch (error) {
                    console.error('Initialization error:', error);
                    showToast('Error initializing app: ' + error.message, 'error');
                }
            }
            
            // Load face-api models with the correct URL
            async function loadFaceApiModels() {
                try {
                    // The correct URL for the model weights
                    const modelUrl = 'https://justadudewhohacks.github.io/face-api.js/weights';
                    
                    showToast('Loading face detection models...', 'info');
                    
                    // Load the models
                    await Promise.all([
                        faceapi.nets.tinyFaceDetector.loadFromUri(modelUrl),
                        faceapi.nets.faceLandmark68Net.loadFromUri(modelUrl)
                    ]);
                    
                    console.log('Face API models loaded successfully');
                    showToast('Face detection models loaded!', 'success');
                } catch (error) {
                    console.error('Error loading face-api models:', error);
                    
                    // Try alternative URL
                    try {
                        const altModelUrl = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights';
                        await Promise.all([
                            faceapi.nets.tinyFaceDetector.loadFromUri(altModelUrl),
                            faceapi.nets.faceLandmark68Net.loadFromUri(altModelUrl)
                        ]);
                        console.log('Face API models loaded from alternative URL');
                        showToast('Face detection models loaded (alternative source)!', 'success');
                    } catch (altError) {
                        console.error('Error loading face-api models from alternative URL:', altError);
                        throw new Error('Failed to load face detection models from all sources');
                    }
                }
            }

            // Setup canvas dimensions based on container
            function setupCanvasDimensions() {
                const canvas = state.resultCanvas;
                const container = canvas.parentElement;
                
                // Set canvas size to match container dimensions
                const containerRect = container.getBoundingClientRect();
                canvas.width = containerRect.width;
                canvas.height = containerRect.height;
                
                // Update comparison slider position
                updateComparisonSlider();
                
                // Update zoom info
                updateZoomPanInfo();
            }

            // Event Listeners Setup
            function setupEventListeners() {
                // Source upload events
                dom.sourceUpload.addEventListener('click', () => dom.sourceInput.click());
                dom.sourceInput.addEventListener('change', handleSourceUpload);
                
                // Target upload events
                dom.targetUpload.addEventListener('click', () => dom.targetInput.click());
                dom.targetInput.addEventListener('change', handleTargetUpload);

                // Replace buttons
                document.querySelectorAll('.replace-button').forEach(button => {
                    button.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const target = this.getAttribute('data-target');
                        if (target === 'source') {
                            dom.sourceInput.click();
                        } else {
                            dom.targetInput.click();
                        }
                    });
                });

                // Drag and drop for source
                setupDragAndDrop(dom.sourceUpload, dom.sourceInput, 'source');

                // Drag and drop for target
                setupDragAndDrop(dom.targetUpload, dom.targetInput, 'target');

                // Canvas interaction
                dom.resultCanvas.addEventListener('wheel', handleZoom);
                dom.resultCanvas.addEventListener('mousedown', startPan);
                document.addEventListener('mousemove', onPan);
                document.addEventListener('mouseup', endPan);
                window.addEventListener('resize', handleResize);
                
                // Comparison slider
                dom.comparisonSlider.addEventListener('mousedown', startComparisonDrag);
                document.addEventListener('mousemove', onComparisonDrag);
                document.addEventListener('mouseup', endComparisonDrag);

                // Touch events for mobile
                dom.resultCanvas.addEventListener('touchstart', handleTouchStart);
                dom.resultCanvas.addEventListener('touchmove', handleTouchMove);
                dom.resultCanvas.addEventListener('touchend', handleTouchEnd);

                // Keyboard shortcuts
                document.addEventListener('keydown', handleKeydown);

                // Control panel toggle for mobile
                dom.toggleControls.addEventListener('click', toggleControls);

                // Control sliders
                dom.scaleSlider.addEventListener('input', updateScale);
                dom.rotationSlider.addEventListener('input', updateRotation);
                dom.xOffsetSlider.addEventListener('input', updateXOffset);
                dom.yOffsetSlider.addEventListener('input', updateYOffset);
                dom.featherSlider.addEventListener('input', updateFeather);

                // Face detection buttons
                dom.reRunButton.addEventListener('click', reRunFaceDetection);
                dom.autoAlignButton.addEventListener('click', autoAlignFaces);
                dom.matchFacesButton.addEventListener('click', matchFaces);
                dom.swapFacesButton.addEventListener('click', swapFaces);
                
                // Color match buttons
                dom.colorMatchOff.addEventListener('click', () => setColorMatch('off'));
                dom.colorMatchSimple.addEventListener('click', () => setColorMatch('simple'));
                dom.colorMatchAdvanced.addEventListener('click', () => setColorMatch('advanced'));
                
                // Mask editing tools
                dom.maskTool.addEventListener('click', toggleMaskEditing);
                dom.maskModePaint.addEventListener('click', () => setMaskMode('paint'));
                dom.maskModeErase.addEventListener('click', () => setMaskMode('erase'));
                
                // Preview mode buttons
                dom.previewSingle.addEventListener('click', () => setPreviewMode('single'));
                dom.previewSplit.addEventListener('click', () => setPreviewMode('split'));
                dom.previewCompare.addEventListener('click', () => setPreviewMode('compare'));
                
                // Toggle buttons
                dom.gridToggle.addEventListener('click', toggleGrid);
                dom.landmarksToggle.addEventListener('click', toggleLandmarks);
                
                // Watermark checkbox
                dom.watermarkCheckbox.addEventListener('change', (e) => {
                    state.settings.addWatermark = e.target.checked;
                    renderCanvas();
                });
                
                // Download button
                dom.downloadButton.addEventListener('click', handleDownload);
                
                // Swap direction button
                dom.swapDirection.addEventListener('click', swapSourceTarget);
                
                // Help modal
                document.getElementById('help-button').addEventListener('click', showHelpModal);
                document.getElementById('close-help').addEventListener('click', hideHelpModal);
            }

            // Drag and Drop Setup
            function setupDragAndDrop(uploadZone, fileInput, type) {
                // Prevent default behavior for drag events
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadZone.addEventListener(eventName, preventDefaults, false);
                });

                function preventDefaults(e) {
                    e.preventDefault();
                    e.stopPropagation();
                }

                // Highlight drop zone when item is dragged over it
                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadZone.addEventListener(eventName, highlight, false);
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    uploadZone.addEventListener(eventName, unhighlight, false);
                });

                function highlight() {
                    uploadZone.classList.add('drag-over');
                }

                function unhighlight() {
                    uploadZone.classList.remove('drag-over');
                }

                // Handle dropped files
                uploadZone.addEventListener('drop', handleDrop, false);

                function handleDrop(e) {
                    const dt = e.dataTransfer;
                    const files = dt.files;
                    
                    if (files.length) {
                        fileInput.files = files;
                        
                        // Create a new Event
                        const event = new Event('change', { 'bubbles': true });
                        fileInput.dispatchEvent(event);
                    }
                }
            }

            // Image Upload Handlers
            function handleSourceUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                // Check file type
                if (!file.type.match('image.*')) {
                    showToast('Please select an image file', 'error');
                    return;
                }
                
                processImage(file, 'source');
            }

            function handleTargetUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                // Check file type
                if (!file.type.match('image.*')) {
                    showToast('Please select an image file', 'error');
                    return;
                }
                
                processImage(file, 'target');
            }

            async function processImage(file, type) {
                try {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const img = await loadImage(e.target.result);
                            
                            // Store the image in state
                            state[`${type}Image`] = img;
                            
                            // Create canvas with proper dimensions
                            const canvas = document.createElement('canvas');
                            canvas.width = img.naturalWidth;
                            canvas.height = img.naturalHeight;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            
                            state[`${type}Canvas`] = canvas;
                            
                            // Update preview
                            const previewImg = document.querySelector(`#${type}-preview img`);
                            previewImg.src = e.target.result;
                            document.getElementById(`${type}-preview`).classList.remove('hidden');
                            document.getElementById(`${type}-file-info`).textContent = 
                                `${file.name} (${(file.size/1024).toFixed(1)} KB)`;
                            
                            // Run face detection
                            await detectFaces(type);
                            
                            // Update canvas
                            renderCanvas();
                            
                            showToast(`Successfully loaded ${type} image`, 'success');
                        } catch (imgError) {
                            console.error(`Error processing image:`, imgError);
                            showToast(`Error processing image: Invalid image format`, 'error');
                        }
                    };
                    reader.onerror = () => {
                        showToast(`Error reading file`, 'error');
                    };
                    reader.readAsDataURL(file);
                } catch (error) {
                    console.error(`Error processing ${type} image:`, error);
                    showToast(`Error processing ${type} image: ${error.message}`, 'error');
                }
            }

            // Face Detection
            async function detectFaces(type) {
                try {
                    if (!state[`${type}Image`]) return;
                    
                    // Show processing state
                    const uploadZone = document.getElementById(`${type}-upload`);
                    const originalContent = uploadZone.innerHTML;
                    uploadZone.innerHTML = `
                        <div class="text-center py-4">
                            <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500 mx-auto"></div>
                            <p class="mt-2 text-gray-600">Detecting faces...</p>
                        </div>
                    `;
                    
                    // Detect faces
                    const options = new faceapi.TinyFaceDetectorOptions({ inputSize: 512 });
                    const detections = await faceapi.detectAllFaces(
                        state[`${type}Image`], 
                        options
                    ).withFaceLandmarks();
                    
                    // Store results
                    state.faces[type] = detections;
                    
                    // Update UI
                    if (detections.length > 0) {
                        populateFaceThumbnails(type, detections);
                        
                        // Auto-select first face
                        if (type === 'source' && detections.length > 0) {
                            selectSourceFace(0);
                        }
                        if (type === 'target' && detections.length > 0) {
                            selectTargetFace(0);
                        }
                    } else {
                        clearFaceSelection(type);
                    }
                    
                    // Reset upload zone
                    uploadZone.innerHTML = originalContent;
                    
                    // Re-setup event listeners for the upload zone
                    setupDragAndDrop(
                        document.getElementById(`${type}-upload`),
                        document.getElementById(`${type}-input`),
                        type
                    );
                    
                    // Show result
                    if (detections.length === 0) {
                        showToast(`No faces detected in ${type} image`, 'warning');
                    } else {
                        showToast(`Detected ${detections.length} face(s) in ${type} image`, 'success');
                    }
                } catch (error) {
                    console.error(`Face detection error for ${type}:`, error);
                    showToast(`Face detection failed: ${error.message}`, 'error');
                    
                    // Reset upload zone
                    const uploadZone = document.getElementById(`${type}-upload`);
                    uploadZone.innerHTML = `
                        <input type="file" id="${type}-input" accept="image/*" class="hidden">
                        <div class="text-gray-500">
                            <p>Drag & drop ${type} image here</p>
                            <p class="text-sm">or click to upload</p>
                        </div>
                        <div id="${type}-preview" class="mt-2 hidden preview-container">
                            <img class="max-w-full h-auto mx-auto rounded-lg" src="" alt="${type} preview">
                            <p class="text-sm text-gray-500 mt-1" id="${type}-file-info"></p>
                            <button class="mt-2 px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600 replace-button" data-target="${type}">Replace</button>
                        </div>
                    `;
                    
                    // Re-setup event listeners
                    const newInput = document.getElementById(`${type}-input`);
                    setupDragAndDrop(
                        document.getElementById(`${type}-upload`),
                        newInput,
                        type
                    );
                    
                    // Add event listeners to the new replace button
                    document.querySelector(`#${type}-preview .replace-button`).addEventListener('click', function(e) {
                        e.stopPropagation();
                        newInput.click();
                    });
                }
            }

            function populateFaceThumbnails(type, detections) {
                const container = document.getElementById(`${type}-face-selection`);
                container.innerHTML = '';
                
                detections.forEach((detection, index) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 60;
                    canvas.height = 60;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw face thumbnail
                    const { x, y, width, height } = detection.detection.box;
                    const scale = 60 / Math.max(width, height);
                    const newWidth = width * scale;
                    const newHeight = height * scale;
                    
                    ctx.drawImage(
                        state[`${type}Image`],
                        x, y, width, height,
                        (60 - newWidth) / 2, (60 - newHeight) / 2, newWidth, newHeight
                    );
                    
                    // Create thumbnail element
                    const thumb = document.createElement('div');
                    thumb.className = `face-thumbnail ${type === 'source' && index === state.selectedSourceFace ? 'active' : type === 'target' && index === state.selectedTargetFace ? 'active' : ''}`;
                    thumb.innerHTML = `<img src="${canvas.toDataURL()}" class="w-full h-full object-cover rounded">`;
                    
                    thumb.addEventListener('click', () => {
                        if (type === 'source') {
                            selectSourceFace(index);
                        } else {
                            selectTargetFace(index);
                        }
                        renderCanvas();
                    });
                    
                    container.appendChild(thumb);
                });
            }

            function clearFaceSelection(type) {
                const container = document.getElementById(`${type}-face-selection`);
                container.innerHTML = '<p class="text-sm text-gray-500">No faces detected</p>';
                
                if (type === 'source') {
                    state.selectedSourceFace = 0;
                    dom.sourceFaceIndicator.textContent = '0';
                } else {
                    state.selectedTargetFace = 0;
                    dom.targetFaceIndicator.textContent = '0';
                }
            }

            function selectSourceFace(index) {
                state.selectedSourceFace = index;
                dom.sourceFaceIndicator.textContent = (index + 1).toString();
                
                // Update UI
                document.querySelectorAll('#source-face-selection .face-thumbnail').forEach((el, i) => {
                    el.classList.toggle('active', i === index);
                });
            }

            function selectTargetFace(index) {
                state.selectedTargetFace = index;
                dom.targetFaceIndicator.textContent = (index + 1).toString();
                
                // Update UI
                document.querySelectorAll('#target-face-selection .face-thumbnail').forEach((el, i) => {
                    el.classList.toggle('active', i === index);
                });
            }

            function reRunFaceDetection() {
                if (state.sourceImage) {
                    detectFaces('source');
                }
                if (state.targetImage) {
                    detectFaces('target');
                }
            }

            function autoAlignFaces() {
                if (!state.sourceImage || !state.targetImage || 
                    state.faces.source.length === 0 || state.faces.target.length === 0) {
                    showToast('Please load images with detected faces first', 'warning');
                    return;
                }
                
                // Simple alignment logic - would be more sophisticated in a real implementation
                state.settings.scale = 1.0;
                state.settings.rotation = 0;
                state.settings.xOffset = 0;
                state.settings.yOffset = 0;
                
                // Update UI
                dom.scaleSlider.value = state.settings.scale;
                dom.scaleValue.textContent = state.settings.scale.toFixed(2);
                
                dom.rotationSlider.value = state.settings.rotation;
                dom.rotationValue.textContent = state.settings.rotation.toFixed(1) + '°';
                
                dom.xOffsetSlider.value = state.settings.xOffset;
                dom.xOffsetValue.textContent = state.settings.xOffset + 'px';
                
                dom.yOffsetSlider.value = state.settings.yOffset;
                dom.yOffsetValue.textContent = state.settings.yOffset + 'px';
                
                renderCanvas();
                showToast('Faces auto-aligned', 'success');
            }

            function matchFaces() {
                if (!state.sourceImage || !state.targetImage || 
                    state.faces.source.length === 0 || state.faces.target.length === 0) {
                    showToast('Please load images with detected faces first', 'warning');
                    return;
                }
                
                // In a real implementation, this would match faces based on similarity
                // For now, we'll just select the first faces
                selectSourceFace(0);
                selectTargetFace(0);
                
                autoAlignFaces();
                showToast('Faces matched based on position', 'success');
            }

            function swapFaces() {
                if (!state.sourceImage || !state.targetImage || 
                    state.faces.source.length === 0 || state.faces.target.length === 0) {
                    showToast('Please load images with detected faces first', 'warning');
                    return;
                }
                
                // Perform the face swap
                renderCanvas();
                showToast('Face swap applied!', 'success');
            }
            
            function setColorMatch(mode) {
                state.settings.colorMatch = mode;
                
                // Update UI
                dom.colorMatchOff.classList.toggle('active', mode === 'off');
                dom.colorMatchSimple.classList.toggle('active', mode === 'simple');
                dom.colorMatchAdvanced.classList.toggle('active', mode === 'advanced');
                
                renderCanvas();
            }
            
            function toggleMaskEditing() {
                state.maskEditing = !state.maskEditing;
                dom.maskTool.classList.toggle('active', state.maskEditing);
                
                if (state.maskEditing) {
                    showToast('Mask editing mode activated', 'info');
                } else {
                    showToast('Mask editing mode deactivated', 'info');
                }
            }
            
            function setMaskMode(mode) {
                state.maskMode = mode;
                dom.maskModePaint.classList.toggle('active', mode === 'paint');
                dom.maskModeErase.classList.toggle('active', mode === 'erase');
                
                showToast(`Mask mode: ${mode === 'paint' ? 'Painting' : 'Erasing'}`, 'info');
            }
            
            function setPreviewMode(mode) {
                state.settings.previewMode = mode;
                
                // Update UI
                dom.previewSingle.classList.toggle('active', mode === 'single');
                dom.previewSplit.classList.toggle('active', mode === 'split');
                dom.previewCompare.classList.toggle('active', mode === 'compare');
                
                // Show/hide comparison slider
                dom.comparisonSlider.classList.toggle('hidden', mode !== 'compare');
                
                renderCanvas();
                showToast(`Preview mode: ${mode === 'single' ? 'Single View' : mode === 'split' ? 'Split View' : 'Before/After'}`, 'info');
            }
            
            function toggleGrid() {
                state.settings.showGrid = !state.settings.showGrid;
                dom.gridToggle.classList.toggle('bg-gray-100', state.settings.showGrid);
                renderCanvas();
            }
            
            function toggleLandmarks() {
                state.settings.showLandmarks = !state.settings.showLandmarks;
                dom.landmarksToggle.classList.toggle('bg-gray-100', state.settings.showLandmarks);
                renderCanvas();
            }
            
            function swapSourceTarget() {
                if (!state.sourceImage || !state.targetImage) {
                    showToast('Both source and target images are required', 'warning');
                    return;
                }
                
                // Swap the images
                const tempImage = state.sourceImage;
                const tempCanvas = state.sourceCanvas;
                const tempFaces = state.faces.source;
                const tempSelectedFace = state.selectedSourceFace;
                
                state.sourceImage = state.targetImage;
                state.sourceCanvas = state.targetCanvas;
                state.faces.source = state.faces.target;
                state.selectedSourceFace = state.selectedTargetFace;
                
                state.targetImage = tempImage;
                state.targetCanvas = tempCanvas;
                state.faces.target = tempFaces;
                state.selectedTargetFace = tempSelectedFace;
                
                // Update UI
                updateSourcePreview();
                updateTargetPreview();
                
                // Repopulate face thumbnails
                if (state.faces.source.length > 0) {
                    populateFaceThumbnails('source', state.faces.source);
                    selectSourceFace(Math.min(state.selectedSourceFace, state.faces.source.length - 1));
                } else {
                    clearFaceSelection('source');
                }
                
                if (state.faces.target.length > 0) {
                    populateFaceThumbnails('target', state.faces.target);
                    selectTargetFace(Math.min(state.selectedTargetFace, state.faces.target.length - 1));
                } else {
                    clearFaceSelection('target');
                }
                
                renderCanvas();
                showToast('Source and target images swapped', 'success');
            }
            
            function updateSourcePreview() {
                if (state.sourceImage) {
                    const previewImg = document.querySelector('#source-preview img');
                    previewImg.src = state.sourceImage.src;
                    document.getElementById('source-preview').classList.remove('hidden');
                }
            }
            
            function updateTargetPreview() {
                if (state.targetImage) {
                    const previewImg = document.querySelector('#target-preview img');
                    previewImg.src = state.targetImage.src;
                    document.getElementById('target-preview').classList.remove('hidden');
                }
            }
            
            function resetAll() {
                // Reset settings to defaults
                state.settings = {
                    scale: 1,
                    rotation: 0,
                    xOffset: 0,
                    yOffset: 0,
                    feather: 5,
                    edgeSmooth: 3,
                    colorMatch: 'advanced',
                    skinTone: 0,
                    brightness: 0,
                    contrast: 0,
                    saturation: 0,
                    brushSize: 20,
                    brushHard: false,
                    maskErase: false,
                    colorTransfer: 'advanced',
                    outputFormat: 'image/png',
                    outputQuality: 90,
                    addWatermark: true,
                    watermarkText: 'FaceSwap Studio Pro',
                    watermarkOpacity: 50,
                    watermarkSize: 20,
                    watermarkPosition: 'bottom-right',
                    stripMeta: true,
                    previewMode: 'single',
                    showLandmarks: false,
                    showGrid: false
                };
                
                state.zoomLevel = 1;
                state.panOffset = { x: 0, y: 0 };
                state.comparisonPosition = 0.5;
                
                // Update UI
                dom.scaleSlider.value = state.settings.scale;
                dom.scaleValue.textContent = state.settings.scale.toFixed(2);
                
                dom.rotationSlider.value = state.settings.rotation;
                dom.rotationValue.textContent = state.settings.rotation.toFixed(1) + '°';
                
                dom.xOffsetSlider.value = state.settings.xOffset;
                dom.xOffsetValue.textContent = state.settings.xOffset + 'px';
                
                dom.yOffsetSlider.value = state.settings.yOffset;
                dom.yOffsetValue.textContent = state.settings.yOffset + 'px';
                
                dom.featherSlider.value = state.settings.feather;
                dom.featherValue.textContent = state.settings.feather + 'px';
                
                dom.colorMatchAdvanced.classList.add('active');
                dom.colorMatchOff.classList.remove('active');
                dom.colorMatchSimple.classList.remove('active');
                
                dom.gridToggle.classList.remove('bg-gray-100');
                dom.landmarksToggle.classList.remove('bg-gray-100');
                
                dom.previewSingle.classList.add('active');
                dom.previewSplit.classList.remove('active');
                dom.previewCompare.classList.remove('active');
                dom.comparisonSlider.classList.add('hidden');
                
                dom.watermarkCheckbox.checked = true;
                
                // Reset mask editing state
                state.maskEditing = false;
                state.maskMode = 'paint';
                dom.maskTool.classList.remove('active');
                dom.maskModePaint.classList.add('active');
                dom.maskModeErase.classList.remove('active');
                
                renderCanvas();
                showToast('All settings reset to defaults', 'success');
            }

            // Responsive Controls Toggle
            function toggleControls() {
                dom.controlsWrapper.classList.toggle('active');
                const icon = dom.toggleControls.querySelector('svg');
                if (dom.controlsWrapper.classList.contains('active')) {
                    icon.innerHTML = '<path fill-rule="evenodd" d="M5.293 12.707a1 1 0 010-1.414L9 7.586l3.707-3.707a1 1 0 111.414 1.414L10.414 9l3.707 3.707a1 1 0 01-1.414 1.414L9 10.414l-3.707 3.707a1 1 0 01-1.414-1.414z" clip-rule="evenodd" />';
                } else {
                    icon.innerHTML = '<path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />';
                }
            }

            // Touch Event Handlers
            let touchStart = { x: 0, y: 0 };
            let lastZoomDistance = 0;
            let isComparisonDragging = false;

            function handleTouchStart(e) {
                if (e.touches.length === 1 && !state.maskEditing) {
                    // Single touch - pan
                    state.isDragging = true;
                    const rect = state.resultCanvas.getBoundingClientRect();
                    state.dragStart.x = e.touches[0].clientX - rect.left;
                    state.dragStart.y = e.touches[0].clientY - rect.top;
                } else if (e.touches.length === 2) {
                    // Pinch to zoom
                    lastZoomDistance = getDistance(e.touches[0], e.touches[1]);
                }
            }

            function handleTouchMove(e) {
                e.preventDefault();
                if (state.isDragging && e.touches.length === 1) {
                    // Pan
                    const rect = state.resultCanvas.getBoundingClientRect();
                    const currentX = e.touches[0].clientX - rect.left;
                    const currentY = e.touches[0].clientY - rect.top;
                    
                    const dx = currentX - state.dragStart.x;
                    const dy = currentY - state.dragStart.y;
                    
                    state.panOffset.x += dx;
                    state.panOffset.y += dy;
                    
                    state.dragStart.x = currentX;
                    state.dragStart.y = currentY;
                    
                    renderCanvas();
                    updateZoomPanInfo();
                } else if (e.touches.length === 2) {
                    // Pinch to zoom
                    const distance = getDistance(e.touches[0], e.touches[1]);
                    const scale = distance / lastZoomDistance;
                    
                    state.zoomLevel *= scale;
                    state.zoomLevel = Math.max(0.5, Math.min(3, state.zoomLevel));
                    
                    lastZoomDistance = distance;
                    
                    renderCanvas();
                    updateZoomPanInfo();
                }
            }

            function handleTouchEnd() {
                state.isDragging = false;
                lastZoomDistance = 0;
            }

            function getDistance(touch1, touch2) {
                return Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
            }

            // Canvas Interaction
            function startPan(e) {
                if (state.maskEditing) {
                    startMaskEditing(e);
                    return;
                }
                
                if (state.settings.previewMode === 'compare') {
                    const rect = dom.comparisonSlider.getBoundingClientRect();
                    const x = e.clientX;
                    
                    if (Math.abs(x - (rect.left + rect.width/2)) < 20) {
                        isComparisonDragging = true;
                        return;
                    }
                }
                
                e.preventDefault();
                state.isDragging = true;
                const rect = state.resultCanvas.getBoundingClientRect();
                state.dragStart.x = e.clientX - rect.left;
                state.dragStart.y = e.clientY - rect.top;
            }

            function onPan(e) {
                if (isComparisonDragging) {
                    onComparisonDrag(e);
                    return;
                }
                
                if (!state.isDragging) return;
                e.preventDefault();
                
                const rect = state.resultCanvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                const dx = currentX - state.dragStart.x;
                const dy = currentY - state.dragStart.y;
                
                state.panOffset.x += dx;
                state.panOffset.y += dy;
                
                state.dragStart.x = currentX;
                state.dragStart.y = currentY;
                
                renderCanvas();
                updateZoomPanInfo();
            }

            function endPan() {
                state.isDragging = false;
                isComparisonDragging = false;
            }
            
            function startComparisonDrag(e) {
                e.preventDefault();
                isComparisonDragging = true;
                onComparisonDrag(e);
            }
            
            function onComparisonDrag(e) {
                if (!isComparisonDragging) return;
                e.preventDefault();
                
                const container = document.getElementById('comparison-container');
                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left;
                
                // Calculate position as a percentage (0-1)
                state.comparisonPosition = Math.max(0, Math.min(1, x / rect.width));
                
                updateComparisonSlider();
                renderCanvas();
            }
            
            function updateComparisonSlider() {
                const container = document.getElementById('comparison-container');
                const rect = container.getBoundingClientRect();
                const position = state.comparisonPosition * rect.width;
                
                dom.comparisonSlider.style.left = `${position}px`;
            }

            function handleZoom(e) {
                e.preventDefault();
                
                // Calculate zoom factor based on wheel delta
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                
                // Update zoom level
                state.zoomLevel *= zoomFactor;
                state.zoomLevel = Math.max(0.5, Math.min(3, state.zoomLevel));
                
                // Adjust pan offset to zoom toward mouse position
                const rect = state.resultCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Calculate new pan offset
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                state.panOffset.x = centerX - (mouseX - state.panOffset.x) * (state.zoomLevel / (state.zoomLevel / zoomFactor));
                state.panOffset.y = centerY - (mouseY - state.panOffset.y) * (state.zoomLevel / (state.zoomLevel / zoomFactor));
                
                renderCanvas();
                updateZoomPanInfo();
            }

            function handleResize() {
                setupCanvasDimensions();
                renderCanvas();
            }

            function updateZoomPanInfo() {
                dom.zoomPanInfo.textContent = `Zoom: ${(state.zoomLevel * 100).toFixed(0)}%`;
            }

            // Control Handlers
            function updateScale() {
                state.settings.scale = parseFloat(dom.scaleSlider.value);
                dom.scaleValue.textContent = state.settings.scale.toFixed(2);
                renderCanvas();
            }

            function updateRotation() {
                state.settings.rotation = parseFloat(dom.rotationSlider.value);
                dom.rotationValue.textContent = state.settings.rotation.toFixed(1) + '°';
                renderCanvas();
            }

            function updateXOffset() {
                state.settings.xOffset = parseInt(dom.xOffsetSlider.value);
                dom.xOffsetValue.textContent = state.settings.xOffset + 'px';
                renderCanvas();
            }

            function updateYOffset() {
                state.settings.yOffset = parseInt(dom.yOffsetSlider.value);
                dom.yOffsetValue.textContent = state.settings.yOffset + 'px';
                renderCanvas();
            }

            function updateFeather() {
                state.settings.feather = parseInt(dom.featherSlider.value);
                dom.featherValue.textContent = state.settings.feather + 'px';
                renderCanvas();
            }

            // Canvas Rendering
            function renderCanvas() {
                if (!state.resultCanvas || !state.resultCtx) return;
                
                const ctx = state.resultCtx;
                
                // Clear canvas
                ctx.clearRect(0, 0, state.resultCanvas.width, state.resultCanvas.height);
                
                if (state.settings.previewMode === 'split') {
                    renderSplitView();
                } else if (state.settings.previewMode === 'compare') {
                    renderComparisonView();
                } else {
                    renderSingleView();
                }
                
                // Draw landmarks if enabled
                if (state.settings.showLandmarks) {
                    drawLandmarks();
                }
                
                // Draw grid if enabled
                if (state.settings.showGrid) {
                    drawGrid();
                }
            }
            
            function renderSingleView() {
                if (!state.targetImage) return;
                
                const ctx = state.resultCtx;
                
                // Calculate dimensions to maintain aspect ratio
                const targetRatio = state.targetImage.width / state.targetImage.height;
                const canvasRatio = state.resultCanvas.width / state.resultCanvas.height;
                
                let drawWidth, drawHeight;
                
                if (canvasRatio > targetRatio) {
                    drawHeight = state.resultCanvas.height;
                    drawWidth = drawHeight * targetRatio;
                } else {
                    drawWidth = state.resultCanvas.width;
                    drawHeight = drawWidth / targetRatio;
                }
                
                // Center the image
                const x = (state.resultCanvas.width - drawWidth) / 2 + state.panOffset.x;
                const y = (state.resultCanvas.height - drawHeight) / 2 + state.panOffset.y;
                
                // Apply zoom
                const zoomedWidth = drawWidth * state.zoomLevel;
                const zoomedHeight = drawHeight * state.zoomLevel;
                
                // Draw the target image
                ctx.drawImage(
                    state.targetImage,
                    x + (drawWidth - zoomedWidth) / 2,
                    y + (drawHeight - zoomedHeight) / 2,
                    zoomedWidth,
                    zoomedHeight
                );
                
                // Draw source face if available and properly aligned
                if (state.sourceImage && 
                    state.faces.source.length > 0 && 
                    state.faces.target.length > 0 &&
                    state.selectedSourceFace < state.faces.source.length &&
                    state.selectedTargetFace < state.faces.target.length) {
                    
                    try {
                        // Get current faces
                        const sourceFace = state.faces.source[state.selectedSourceFace];
                        const targetFace = state.faces.target[state.selectedTargetFace];
                        
                        // Calculate face alignment
                        const sourceWidth = sourceFace.detection.box.width;
                        const sourceHeight = sourceFace.detection.box.height;
                        const targetWidth = targetFace.detection.box.width;
                        const targetHeight = targetFace.detection.box.height;
                        
                        // Scale factor based on face size and user settings
                        const scale = Math.min(
                            targetWidth / sourceWidth,
                            targetHeight / sourceHeight
                        ) * state.settings.scale;
                        
                        // Position based on target face center
                        const targetCenterX = targetFace.detection.box.x + targetWidth / 2;
                        const targetCenterY = targetFace.detection.box.y + targetHeight / 2;
                        
                        // Apply offsets
                        const offsetX = state.settings.xOffset * 2; // Adjust for scale
                        const offsetY = state.settings.yOffset * 2;
                        
                        // Draw source face
                        ctx.save();
                        ctx.translate(
                            targetCenterX + offsetX,
                            targetCenterY + offsetY
                        );
                        ctx.rotate(state.settings.rotation * Math.PI / 180);
                        ctx.scale(scale, scale);
                        ctx.translate(
                            -sourceFace.detection.box.x - sourceWidth / 2,
                            -sourceFace.detection.box.y - sourceHeight / 2
                        );
                        
                        // Apply color matching if enabled
                        if (state.settings.colorMatch !== 'off') {
                            // In a real implementation, this would adjust colors to match
                            // For now, we'll just apply a simple tint for demonstration
                            if (state.settings.colorMatch === 'advanced') {
                                ctx.globalAlpha = 0.9;
                                ctx.fillStyle = 'rgba(20, 10, 5, 0.05)';
                                ctx.fillRect(0, 0, sourceWidth, sourceHeight);
                                ctx.globalAlpha = 1.0;
                            }
                        }
                        
                        ctx.drawImage(
                            state.sourceImage,
                            0, 0
                        );
                        ctx.restore();
                        
                        // Apply feathering effect
                        if (state.settings.feather > 0) {
                            const feather = state.settings.feather;
                            const gradient = ctx.createRadialGradient(
                                targetCenterX, targetCenterY, Math.min(targetWidth, targetHeight) * 0.3,
                                targetCenterX, targetCenterY, Math.min(targetWidth, targetHeight) * 0.6
                            );
                            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                            gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                            
                            ctx.save();
                            ctx.globalCompositeOperation = 'destination-in';
                            ctx.fillStyle = gradient;
                            ctx.fillRect(
                                targetCenterX - targetWidth * 0.6,
                                targetCenterY - targetHeight * 0.6,
                                targetWidth * 1.2,
                                targetHeight * 1.2
                            );
                            ctx.restore();
                        }
                        
                    } catch (error) {
                        console.error('Error rendering face:', error);
                    }
                }
            }
            
            function renderSplitView() {
                if (!state.targetImage) return;
                
                const ctx = state.resultCtx;
                const canvasWidth = state.resultCanvas.width;
                const canvasHeight = state.resultCanvas.height;
                
                // Left side - original target
                renderTargetImage(ctx, 0, 0, canvasWidth/2, canvasHeight);
                
                // Right side - swapped image
                ctx.save();
                ctx.beginPath();
                ctx.rect(canvasWidth/2, 0, canvasWidth/2, canvasHeight);
                ctx.clip();
                renderSingleView();
                ctx.restore();
                
                // Draw divider line
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(canvasWidth/2, 0);
                ctx.lineTo(canvasWidth/2, canvasHeight);
                ctx.stroke();
            }
            
            function renderComparisonView() {
                if (!state.targetImage) return;
                
                const ctx = state.resultCtx;
                const canvasWidth = state.resultCanvas.width;
                const canvasHeight = state.resultCanvas.height;
                
                // Draw original target image
                renderTargetImage(ctx, 0, 0, canvasWidth, canvasHeight);
                
                // Draw swapped image with mask
                ctx.save();
                ctx.beginPath();
                ctx.rect(0, 0, canvasWidth * state.comparisonPosition, canvasHeight);
                ctx.clip();
                renderSingleView();
                ctx.restore();
                
                // Update comparison slider position
                updateComparisonSlider();
            }
            
            function renderTargetImage(ctx, x, y, width, height) {
                if (!state.targetImage) return;
                
                // Calculate dimensions to maintain aspect ratio
                const targetRatio = state.targetImage.width / state.targetImage.height;
                const canvasRatio = width / height;
                
                let drawWidth, drawHeight;
                
                if (canvasRatio > targetRatio) {
                    drawHeight = height;
                    drawWidth = drawHeight * targetRatio;
                } else {
                    drawWidth = width;
                    drawHeight = drawWidth / targetRatio;
                }
                
                // Center the image
                const imgX = x + (width - drawWidth) / 2 + state.panOffset.x;
                const imgY = y + (height - drawHeight) / 2 + state.panOffset.y;
                
                // Apply zoom
                const zoomedWidth = drawWidth * state.zoomLevel;
                const zoomedHeight = drawHeight * state.zoomLevel;
                
                // Draw the target image
                ctx.drawImage(
                    state.targetImage,
                    imgX + (drawWidth - zoomedWidth) / 2,
                    imgY + (drawHeight - zoomedHeight) / 2,
                    zoomedWidth,
                    zoomedHeight
                );
            }

            function drawGrid() {
                const ctx = state.resultCtx;
                const gridSize = 50;
                
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.lineWidth = 0.5;
                
                // Vertical lines
                for (let x = 0; x < state.resultCanvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, state.resultCanvas.height);
                    ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 0; y < state.resultCanvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(state.resultCanvas.width, y);
                    ctx.stroke();
                }
            }
            
            function drawLandmarks() {
                if (!state.targetImage || state.faces.target.length === 0) return;
                
                const ctx = state.resultCtx;
                const targetFace = state.faces.target[state.selectedTargetFace];
                
                // Draw landmarks for target face
                if (targetFace && targetFace.landmarks) {
                    const positions = targetFace.landmarks.positions;
                    
                    ctx.fillStyle = 'red';
                    positions.forEach(pos => {
                        ctx.beginPath();
                        ctx.arc(pos._x, pos._y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
                
                if (!state.sourceImage || state.faces.source.length === 0) return;
                
                const sourceFace = state.faces.source[state.selectedSourceFace];
                
                // Draw landmarks for source face (if we can map them to target position)
                if (sourceFace && sourceFace.landmarks && targetFace) {
                    const sourcePositions = sourceFace.landmarks.positions;
                    const targetPositions = targetFace.landmarks.positions;
                    
                    // Only draw if we have matching landmarks
                    if (sourcePositions.length === targetPositions.length) {
                        const sourceWidth = sourceFace.detection.box.width;
                        const sourceHeight = sourceFace.detection.box.height;
                        const targetWidth = targetFace.detection.box.width;
                        const targetHeight = targetFace.detection.box.height;
                        
                        // Scale factor based on face size and user settings
                        const scale = Math.min(
                            targetWidth / sourceWidth,
                            targetHeight / sourceHeight
                        ) * state.settings.scale;
                        
                        // Position based on target face center
                        const targetCenterX = targetFace.detection.box.x + targetWidth / 2;
                        const targetCenterY = targetFace.detection.box.y + targetHeight / 2;
                        
                        // Apply offsets
                        const offsetX = state.settings.xOffset * 2;
                        const offsetY = state.settings.yOffset * 2;
                        
                        ctx.fillStyle = 'blue';
                        for (let i = 0; i < sourcePositions.length; i++) {
                            const sourcePos = sourcePositions[i];
                            const targetPos = targetPositions[i];
                            
                            // Calculate position in target image
                            const dx = sourcePos._x - (sourceFace.detection.box.x + sourceWidth / 2);
                            const dy = sourcePos._y - (sourceFace.detection.box.y + sourceHeight / 2);
                            
                            const newX = targetCenterX + offsetX + dx * scale;
                            const newY = targetCenterY + offsetY + dy * scale;
                            
                            ctx.beginPath();
                            ctx.arc(newX, newY, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }

            // Keyboard Shortcuts
            function handleKeydown(e) {
                // Prevent default for certain keys when input isn't focused
                if (!['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                    e.preventDefault();
                }
                
                // Ctrl+Z for undo
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    // undo();
                }
                // Ctrl+Y for redo
                else if (e.ctrlKey && e.key === 'y') {
                    e.preventDefault();
                    // redo();
                }
                // Ctrl+S for download
                else if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    handleDownload();
                }
                // + or - for zoom
                else if (e.key === '+' || e.key === '=') {
                    state.zoomLevel *= 1.1;
                    state.zoomLevel = Math.min(3, state.zoomLevel);
                    renderCanvas();
                    updateZoomPanInfo();
                }
                else if (e.key === '-' || e.key === '_') {
                    state.zoomLevel *= 0.9;
                    state.zoomLevel = Math.max(0.5, state.zoomLevel);
                    renderCanvas();
                    updateZoomPanInfo();
                }
                // 0 to reset zoom
                else if (e.key === '0') {
                    state.zoomLevel = 1;
                    state.panOffset = { x: 0, y: 0 };
                    renderCanvas();
                    updateZoomPanInfo();
                }
                // G to toggle grid
                else if (e.key === 'g' || e.key === 'G') {
                    toggleGrid();
                }
                // L to toggle landmarks
                else if (e.key === 'l' || e.key === 'L') {
                    toggleLandmarks();
                }
                // C to toggle compare
                else if (e.key === 'c' || e.key === 'C') {
                    if (state.settings.previewMode === 'compare') {
                        setPreviewMode('single');
                    } else {
                        setPreviewMode('compare');
                    }
                }
                // Space + drag for pan
                if (e.key === ' ') {
                    document.body.style.cursor = 'move';
                }
            }

            // Mask Editing
            function startMaskEditing(e) {
                if (!state.maskEditing) return;
                
                const rect = state.resultCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // In a real implementation, this would start drawing on the mask
                // For now, we'll just show a visual indicator
                const ctx = state.resultCtx;
                ctx.beginPath();
                ctx.arc(x, y, state.maskBrushSize, 0, Math.PI * 2);
                ctx.fillStyle = state.maskMode === 'paint' ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.3)';
                ctx.fill();
            }

            // Download Handling
            function handleDownload() {
                if (!state.targetImage) {
                    showToast('Please load a target image first', 'warning');
                    return;
                }
                
                try {
                    // Create a temporary canvas for export
                    const exportCanvas = document.createElement('canvas');
                    const exportCtx = exportCanvas.getContext('2d');
                    
                    // Set dimensions to match original target image
                    exportCanvas.width = state.targetImage.naturalWidth;
                    exportCanvas.height = state.targetImage.naturalHeight;
                    
                    // Draw target image
                    exportCtx.drawImage(state.targetImage, 0, 0);
                    
                    // Draw source face if available
                    if (state.sourceImage && 
                        state.faces.source.length > 0 && 
                        state.faces.target.length > 0 &&
                        state.selectedSourceFace < state.faces.source.length &&
                        state.selectedTargetFace < state.faces.target.length) {
                        
                        try {
                            // Get current faces
                            const sourceFace = state.faces.source[state.selectedSourceFace];
                            const targetFace = state.faces.target[state.selectedTargetFace];
                            
                            // Calculate face alignment
                            const sourceWidth = sourceFace.detection.box.width;
                            const sourceHeight = sourceFace.detection.box.height;
                            const targetWidth = targetFace.detection.box.width;
                            const targetHeight = targetFace.detection.box.height;
                            
                            // Scale factor based on face size and user settings
                            const scale = Math.min(
                                targetWidth / sourceWidth,
                                targetHeight / sourceHeight
                            ) * state.settings.scale;
                            
                            // Position based on target face center
                            const targetCenterX = targetFace.detection.box.x + targetWidth / 2;
                            const targetCenterY = targetFace.detection.box.y + targetHeight / 2;
                            
                            // Apply offsets
                            const offsetX = state.settings.xOffset * 2;
                            const offsetY = state.settings.yOffset * 2;
                            
                            // Draw source face
                            exportCtx.save();
                            exportCtx.translate(
                                targetCenterX + offsetX,
                                targetCenterY + offsetY
                            );
                            exportCtx.rotate(state.settings.rotation * Math.PI / 180);
                            exportCtx.scale(scale, scale);
                            exportCtx.translate(
                                -sourceFace.detection.box.x - sourceWidth / 2,
                                -sourceFace.detection.box.y - sourceHeight / 2
                            );
                            
                            // Apply color matching if enabled
                            if (state.settings.colorMatch !== 'off') {
                                // In a real implementation, this would adjust colors to match
                                // For now, we'll just apply a simple tint for demonstration
                                if (state.settings.colorMatch === 'advanced') {
                                    exportCtx.globalAlpha = 0.9;
                                    exportCtx.fillStyle = 'rgba(20, 10, 5, 0.05)';
                                    exportCtx.fillRect(0, 0, sourceWidth, sourceHeight);
                                    exportCtx.globalAlpha = 1.0;
                                }
                            }
                            
                            exportCtx.drawImage(
                                state.sourceImage,
                                0, 0
                            );
                            exportCtx.restore();
                            
                            // Apply feathering effect
                            if (state.settings.feather > 0) {
                                const feather = state.settings.feather;
                                const gradient = exportCtx.createRadialGradient(
                                    targetCenterX, targetCenterY, Math.min(targetWidth, targetHeight) * 0.3,
                                    targetCenterX, targetCenterY, Math.min(targetWidth, targetHeight) * 0.6
                                );
                                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                                gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
                                
                                exportCtx.save();
                                exportCtx.globalCompositeOperation = 'destination-in';
                                exportCtx.fillStyle = gradient;
                                exportCtx.fillRect(
                                    targetCenterX - targetWidth * 0.6,
                                    targetCenterY - targetHeight * 0.6,
                                    targetWidth * 1.2,
                                    targetHeight * 1.2
                                );
                                exportCtx.restore();
                            }
                            
                        } catch (error) {
                            console.error('Error rendering face for export:', error);
                        }
                    }
                    
                    // Add watermark if enabled
                    if (state.settings.addWatermark) {
                        const watermarkText = state.settings.watermarkText;
                        const fontSize = state.settings.watermarkSize;
                        exportCtx.font = `bold ${fontSize}px Arial`;
                        exportCtx.fillStyle = `rgba(0, 0, 0, ${state.settings.watermarkOpacity / 100})`;
                        
                        const textWidth = exportCtx.measureText(watermarkText).width;
                        const padding = 20;
                        
                        let x, y;
                        switch (state.settings.watermarkPosition) {
                            case 'top-left':
                                x = padding;
                                y = fontSize + padding;
                                break;
                            case 'top-right':
                                x = exportCanvas.width - textWidth - padding;
                                y = fontSize + padding;
                                break;
                            case 'bottom-left':
                                x = padding;
                                y = exportCanvas.height - padding;
                                break;
                            default: // bottom-right
                                x = exportCanvas.width - textWidth - padding;
                                y = exportCanvas.height - padding;
                        }
                        
                        exportCtx.fillText(watermarkText, x, y);
                    }
                    
                    // Create download link
                    const link = document.createElement('a');
                    link.download = 'faceswap-result.png';
                    link.href = exportCanvas.toDataURL('image/png');
                    link.click();
                    
                    showToast('Image exported successfully!', 'success');
                } catch (error) {
                    console.error('Export error:', error);
                    showToast('Error exporting image: ' + error.message, 'error');
                }
            }

            // Helper Functions
            function showToast(message, type = 'success') {
                const toast = document.createElement('div');
                toast.className = `toast px-4 py-2 rounded-lg text-white ${type === 'error' ? 'bg-red-500' : type === 'warning' ? 'bg-yellow-500' : type === 'info' ? 'bg-blue-500' : 'bg-green-500'}`;
                toast.textContent = message;
                document.getElementById('toast-container').appendChild(toast);
                
                // Auto-remove after delay
                setTimeout(() => {
                    toast.style.animation = 'slideIn 0.3s, fadeOut 0.3s 2.7s forwards';
                    setTimeout(() => toast.remove(), 3000);
                }, 3000);
            }

            function loadImage(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = (e) => reject(new Error('Failed to load image'));
                    img.src = src;
                });
            }

            function showHelpModal() {
                document.getElementById('help-modal').classList.remove('hidden');
            }

            function hideHelpModal() {
                document.getElementById('help-modal').classList.add('hidden');
            }

            // Start application
            document.addEventListener('DOMContentLoaded', initApp);
        })();
    </script>
</body>
</html>
